###  一. 理论

* 系统开机启动流程
* 系统调用和函数调用

> 1. 区别
> 2. 分析明白一个系统调用的全部过程， 从用户态到内核态

* x86启动顺序

> 1. 加电启动之后处于实模式， 20位寻址空间， 是为了向下兼容
> 2. 先读取BIOS， BIOS做一些硬件初始化， 自检；并加载存储设备的第一个引导扇区（主引导扇区：512字节）， 读取到内存（BootLoader)
> 3. BootLoader： 从实模式切换到保护模式，此时可以使用段机制；同时从硬盘上读取kernel到内存固定位置，并跳转到ucore OS的入口点，将执行权交到ucore OS中； 建立GDT（全局描述符表），使得CPU可以找到GDT

* 内联汇编

> 1. C语言无法完成一些特权级操作，需要汇编完成

* 中断处理过程

> 1. 中断描述符表：IDT；其地址存储在IDTR寄存器中；IDT中存储中断或异常服务例程的地址
> 2. iret 与 ret 与 retf： 都是返回，只是有时候中断产生现场恢复时，前后特权级发生了变化，所以push和pop的值不同

### 二. 实验

* 练习1

  >  `make V=` : 该命令可以详细的显示make的执行过程
  >
  > tools/sign.c 文件中验证了一个被系统认为是符合规范的硬盘主引导扇区的特征 

* 练习2

> 1. 调试bootloader的方法， 注意使用gdb显示命令的时候， 如果要找对应的命令， 可以在Eclipse中查看其汇编代码

* 练习3

> 1. 寻址方式发生改变， 从实模式到保护模式
> 2. 代码在bootloader.c中， 可以查看对应汇编文件（proj1中）
> 3. 也可以在该文件夹下执行`make qemu`
> 4. 查看对应视频04/9-7

* 练习4

> 1. bin/kernel 下的ELF文件
> 2. 由proj2完成这个事情
> 3. 视频04/9-8
> 4. 读取扇区： readsect()函数 （bootmain.c）

* 练习5

> 1. 分析函数调用栈
> 2. 填的内容也很少，就两句话， 但是需要把细节掌握清楚

* 练习6

> 1. 建立中断向量表： idt_init()
> 2. lidt() 函数完成对中断描述符表的加载， 通知CPU中断描述符表建立完成
> 3. 使能中断： sti()
> 4. 中断服务例程的入口地址：在verctors.S中

* 扩展练习

> 1. 实现特权级的切换